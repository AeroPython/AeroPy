La parte C++ está completada (salvo añadir comentarios y demás...).

Quedaría hacerle un pequeño wrapper en Python con la interfaz que se acordó,
pero eso ya es sencillo y espero poder dearlo pulido pronto. De momento, 
he logrado solventar los problemas que expuse utilizando una interfaz basada
en subrutinas.

Aún falta mucho además de la interfaz, python arrojará excepciones si no se
le pasan los argumentos a las funciones con el tipo adecuado (tipo float de
python), las funciones comunican sus errores devolviendo enteros, etc, etc.
Tampoco me ha dado tiempo a comprobar los valores que arroja, más que por
encima.

Si alguien quiere probarlo, no debería dar problema alguno
si lo compiláis desde linux (o en Windows si tenéis instalado el mismo
compilador con el que fue compilada vuestra distribución Python).

Utiliando disutils, simplemente tenéis que correr el siguiente comando estando
situados en el directorio "isaccp" (donde están los fuentes):

    python setup.py build_ext --inplace

Podéis probar el siguiente código de ejemplo abriendo una terminal de
python/ipython en dicho directorio:



from isacpp import ISACpp
import numpy as np

dt = 15.
ISA = ISACpp(dt)    # Objeto que contiene las funciones que calculan T, p y rho

# Vectores para almacenar los datos
h = np.linspace(1., 1e5, 250)
T = np.empty(250)
p = np.empty(250)
rho = np.empty(250)

# En vez de funcionar como funciones, los métodos de ISACpp escriben
# en nuestros vectores. El valor entero devuelto es 0 si no se producen errores
ISA.T(h, T)
ISA.p(h, p)
ISA.rho(h, rho)

